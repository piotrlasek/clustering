/*
 * DataView.java
 *
 * Created on 13 maj 2005, 11:19
 */

package org.dmtools.clustering.algorithm.NBC.required;

import javax.swing.*;

import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Random;
import java.util.Set;

import java.awt.Dimension;
import javax.swing.JPanel;
import java.awt.GridBagLayout;
import java.awt.Color;
import java.awt.BorderLayout;

/**
 * 
 * @author pl
 */
public class DataView2D extends JFrame implements IClusteringObserver, IClusteringDataSource {

	ArrayList<PointView> al = new ArrayList<PointView>();
	
	String desc = null;
	
	double[] cellSizes;
	
	HashMap<Integer, PointView> cl = new HashMap<Integer, PointView>();
	
	//String algorithmName;
	
	//MainWindow mw = null;
	
	int pointsBefore = 0;
	
	int nDim = 2;
	
	String id = "";  //  @jve:decl-index=0:
	
	static int a = 0;

	private JPanel jPanel1 = null;

	private JPanel jPanel3 = null;

	/** Creates new form DataView */
	public DataView2D(/*MainWindow refMw*/) {
		//mw = refMw;
		initComponents();
		this.setSize(380, 380);
		this.setBackground(Color.white);
	}
	
	public ArrayList<PointView> getPoints()
	{
		return al;
	}
	
	public void setPoints(ArrayList<PointView> points)
	{
		al.clear();
		al.addAll(points);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc=" Generated Code
	// ">//GEN-BEGIN:initComponents
	private void initComponents() {
		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		this.setContentPane(getJPanel1());
		this.setSize(new Dimension(464, 255));
		setBackground(new java.awt.Color(255, 255, 255));
		addMouseListener(new java.awt.event.MouseAdapter() {
			public void mousePressed(java.awt.event.MouseEvent evt) {
				formMousePressed(evt);
			}

			public void mouseReleased(java.awt.event.MouseEvent evt) {
				formMouseReleased(evt);
			}
		});
		addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
			public void mouseDragged(java.awt.event.MouseEvent evt) {
				formMouseDragged(evt);
			}
		});
		addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosed(java.awt.event.WindowEvent evt) {
				formWindowClosed(evt);
			}
		});
		addWindowFocusListener(new java.awt.event.WindowFocusListener() {
			public void windowGainedFocus(java.awt.event.WindowEvent evt) {
				formWindowGainedFocus(evt);
			}

			public void windowLostFocus(java.awt.event.WindowEvent evt) {
				formWindowLostFocus(evt);
			}
		});

		//getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

		pack();
	}

	// </editor-fold>//GEN-END:initComponents

	private void formMouseReleased(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseReleased
	// TODO add your handling code here:
		/*mw.addLog("Number of new points: " + (al.size() - pointsBefore)
				+ ", total number of points: " + al.size());*/
	}// GEN-LAST:event_formMouseReleased

	private void formMousePressed(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMousePressed
	// TODO add your handling code here:
		pointsBefore = al.size();
	}// GEN-LAST:event_formMousePressed

	private void formMouseDragged(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseDragged
	// TODO add your handling code here:
		Random r = new Random();
		int pointsBefore = al.size();
		
		int pointsNumber = 3;
		
		if (evt.isControlDown())
		{
		    pointsNumber = 10;
		    System.out.println("Control Down");
		}

		for (int i = 0; i < pointsNumber; i++) {
			double[] coords = new double[2];
			coords[0] = (double) (evt.getX() + r.nextInt(40) + 0);
			coords[1] = (double) (evt.getY() + r.nextInt(40) - 45);
			
			if ( coords[0] >= 0 && coords[1] >= 0 && coords[0] < this.jPanel3.getSize().width && coords[1] < this.jPanel3.getSize().height)
			{
				System.out.println("" + coords[0] + " " + coords[1]);
				
				PointView p = new PointView(coords, -1);
				
				if (!al.contains(p))
				{
					al.add(p);
					paintPoint(getGraphx(), al.size() - 1);
				}
			}
		}
	}// GEN-LAST:event_formMouseDragged

	private void formWindowClosed(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_formWindowClosed
		//mw.activeWnd = -1;
	}// GEN-LAST:event_formWindowClosed

	private void formWindowLostFocus(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_formWindowLostFocus

	}// GEN-LAST:event_formWindowLostFocus

	private void formWindowGainedFocus(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_formWindowGainedFocus
	// TODO add your handling code here:
		/*if (mw != null) {
		    mw.activeWnd = mw.wnds.indexOf(this);
		    mw.dsm.setActiveDataSource(id);
		}*/
    		//System.out.println("Focus gained: " + id);
	}// GEN-LAST:event_formWindowGainedFocus

	@Override
	public void paint(Graphics g) {
		// System.out.println(a++);
		super.paint(g);
		paintLines(getGraphx());
		paintData(getGraphx());
		paintClusters(getGraphx());
		paintTime();
	}
	
	public void repaint() {
		super.repaint();
		paintLines(getGraphx());
                paintData(getGraphx());
                paintClusters(getGraphx());
                paintTime();
	}
	
	public void paintTime() {
    	    if (desc != null) {
    	        desc = desc.replace("\t", "  ");
    	        Graphics g = getGraphx();
                g.setColor(Color.black);
                g.setFont(new Font("Arial", Font.BOLD, 12));
        
                int x = 10;
                int y = this.getHeight() - 50;
                int w = this.getWidth();
                g.setColor(Color.LIGHT_GRAY);
                g.drawRect(x - 5, y + 8, w - x - x, -25);
                
                g.setColor(Color.black);
                g.drawString(desc, x, y);
                //g.drawString(desc, 40, 40);
    	    }
	}
	
	public void paintLines(Graphics g)
	{
		/**/
		double[] cs = this.cellSizes;
		g.setColor(Color.lightGray);
		if (cellSizes != null)
		{
			int maxY = this.getSize().height;
			int maxX = this.getSize().width;
			
			for (int i = 0; i < maxX / cs[0]; i++)
				g.drawLine((int) (i*cs[0]), 0, (int) (i*cs[0]), maxY);
			
			for (int i = 0; i < maxY / cs[1]; i++)
				g.drawLine(0, (int) (i*cs[1]), maxX, (int) (i*cs[1]));
		}
	}
	
	public void paintData(Graphics g) {
		for (int i = 0; i < al.size(); i++) {
			paintPoint(g, i);
		}
	}
	
	public void paintClusters(Graphics g) {
		g.setColor(Color.black);
		g.setFont(new Font("Arial", Font.BOLD, 12));
		Set<Integer> keys = cl.keySet();
		
		for(Integer key:keys)
		{
			PointView pv = cl.get(key);
			if (pv.c >= 0)
				g.drawString(key.toString(), (int)pv.m_pCoords[0], (int)pv.m_pCoords[1]);
		}
	}

	public void paintPoint(Graphics g, int i) {
		PointView point = (PointView) al.get(i);
		int yoff = 0;
		int xoff = 0;
		g.setColor(getColor(point.c));
		
		g.drawLine((int)point.m_pCoords[0], (int)point.m_pCoords[1], (int)point.m_pCoords[0], (int)point.m_pCoords[1]);
		g.drawLine((int)point.m_pCoords[0], (int)point.m_pCoords[1], (int)point.m_pCoords[0]+1, (int)point.m_pCoords[1]);
		g.drawLine((int)point.m_pCoords[0], (int)point.m_pCoords[1], (int)point.m_pCoords[0], (int)point.m_pCoords[1]+1);
		g.drawLine((int)point.m_pCoords[0], (int)point.m_pCoords[1], (int)point.m_pCoords[0]+1, (int)point.m_pCoords[1]+1);
		
		/*if (point.c != 0) {
			g.drawLine((int) point.m_pCoords[0] - 1,
					(int) point.m_pCoords[1] - 1, (int) point.m_pCoords[0] + 1,
					(int) point.m_pCoords[1] + 1);
			g.drawLine((int) point.m_pCoords[0] + 1,
					(int) point.m_pCoords[1] - 1, (int) point.m_pCoords[0] - 1,
					(int) point.m_pCoords[1] + 1);

		} else {
			g.drawLine((int) point.m_pCoords[0] - 1,
					(int) point.m_pCoords[1] - 1, (int) point.m_pCoords[0] + 1,
					(int) point.m_pCoords[1] + 1);
			g.drawLine((int) point.m_pCoords[0] + 1,
					(int) point.m_pCoords[1] - 1, (int) point.m_pCoords[0] - 1,
					(int) point.m_pCoords[1] + 1);
		}*/
	}

	public Color getColor(int c) {

		switch (c) {
		case -1:
			return Color.gray; // unclassified
		case -2:
			return Color.gray; // noise
		}
		
		switch (c % 6) {
		case 0:
			return Color.pink;
		// return new Color(Color.pink.getRGB(), Color.pink.getGreen(),
		// Color.pink.getBlue(), a);
		case 1:
			return Color.magenta;
		// return new Color(Color.red.getRGB(), Color.red.getGreen(),
		// Color.red.getBlue(), a);
		case 2:
			return Color.cyan;
		// return new Color(Color.cyan.getRGB(), Color.cyan.getGreen(),
		// Color.cyan.getBlue(), a);
		case 3:
			return Color.orange;
		// return new Color(Color.blue.getRGB(), Color.blue.getGreen(),
		// Color.blue.getBlue(), a);
		case 4:
			return Color.pink;
		// return new Color(Color.darkGray.getRGB(), Color.darkGray.getGreen(),
		// Color.darkGray.getBlue(), a);
		case 5:
			return Color.green;
		// return new Color(Color.green.getRGB(), Color.green.getGreen(),
		// Color.green.getBlue(), a);
		case 6:
			return Color.yellow;
		// return new Color(Color.yellow.getRGB(), Color.yellow.getGreen(),
		// Color.yellow.getBlue(), a);
		default:
			return getColor(c/2);
		}
	}

	@Override
	public void handleNotify(IClusteringData data) {
		// TODO Auto-generated method stub
		al.clear();
		cl.clear();
		
		if (data != null)
		{
			Collection<IClusteringObject> list = data.get();
			
			if (list != null)
			{
				for (IClusteringObject o:list)
				{
					double coordinates[] = o.getSpatialObject().getCoordinates();
					int c = o.getClusterInfo().getClusterId();
					PointView pv = new PointView(coordinates, c);
					al.add(pv);
					if ( !cl.containsKey( new Integer(c)))
					{
						cl.put(new Integer(c), pv);
					}			
				}
			}
			
			repaint();
		}
	}
	
	@Override
	public void handleNotify(String message) {
            // this.jLabel.setText(message);
            /*if (mw != null) {
                mw.addLog(message);
            } else {
                System.out.println(message);
            }*/
            
            this.desc = message;
        }

	@Override
	public IClusteringData getData()
	{
		BasicClusteringData bcd = new BasicClusteringData();
		Collection<IClusteringObject> list = new ArrayList<IClusteringObject>();
		
		for (PointView p:al)
		{
			BasicClusteringObject bco = new BasicClusteringObject();
			BasicSpatialObject so = new BasicSpatialObject(p.m_pCoords);
			BasicClusterInfo bci = new BasicClusterInfo();
			bci.setClusterId(p.c);
			
			bco.setSpatialObject(so);
			bco.setClusterInfo(bci);
			
			list.add(bco);
		}
		
		bcd.set(list);
		
		return bcd;
	}

	@Override
	public void setData(IClusteringData clusteringOutput) {
	    
	        al.clear();
	        cl.clear();

		Collection<IClusteringObject> objects = clusteringOutput.get();
		
		for(IClusteringObject o:objects)
		{
			double[] coords = o.getSpatialObject().getCoordinates();
			int classId= o.getClusterInfo().getClusterId();
			
			PointView p = new PointView(coords, classId);
			
			if (!al.contains(p))
			{
				al.add(p);
				paintPoint(getGraphx(), al.size() - 1);
			}
		}
	}

	@Override
	public void handleNotify(Object object) {
		double[] cellSizes = (double[]) object;
		this.cellSizes = cellSizes;
		repaint();
	}
	
	public Graphics getGraphx()
	{
		return this.jPanel3.getGraphics();
	}

	/**
	 * This method initializes jPanel1	
	 * 	
	 * @return javax.swing.JPanel	
	 */
	private JPanel getJPanel1() {
		if (jPanel1 == null) {
			jPanel1 = new JPanel();
			jPanel1.setLayout(new BorderLayout());
			jPanel1.setBackground(Color.white);
			jPanel1.add(getJPanel3(), BorderLayout.CENTER);
		}
		return jPanel1;
	}

	/**
	 * This method initializes jPanel3	
	 * 	
	 * @return javax.swing.JPanel	
	 */
	private JPanel getJPanel3() {
		if (jPanel3 == null) {
			jPanel3 = new JPanel();
			jPanel3.setLayout(new GridBagLayout());
			jPanel3.setBackground(Color.white);
		}
		return jPanel3;
	}

	@Override
	public void saveDataSource() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void showDataSource() {
		// TODO Auto-generated method stub
		this.setVisible(true);
	}

	@Override
	public String getId() {
		// TODO Auto-generated method stub
		return id;
	}

	@Override
	public void setId(String id) {
		// TODO Auto-generated method stub
		this.id = id;
		setTitle(id);
	}

    @Override
    public void close() {
        // TODO Auto-generated method stub
        this.dispose();
        
    }
	
}  //  @jve:decl-index=0:visual-constraint="14,6"
